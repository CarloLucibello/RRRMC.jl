{
    "docs": [
        {
            "location": "/", 
            "text": "RRRMC.jl documentation\n\n\nThis package implements the Reduced-Rejection-Rate (RRR) Monte Carlo method for Ising spin models described in the paper \"A method to reduce the rejection rate in Monte Carlo Markov Chains on Ising spin models\" by C. Baldassi.\n\n\nIt also provides a standard Metropolis-Hastings sampler, and an implementation of the BKL method described in the paper \n\"A new algorithm for Monte Carlo simulation of Ising spin systems\"\n by A.B. Bortz, M.H. Kalos and J.L. Lebowitz\n\n\nThe code is written in \nJulia\n, and tested against Julia \n0.4\n, \n0.5\n and \ncurrent\n \n0.6-dev\n on Linux, OS X, and Windows.\n\n\n\n\nInstallation\n\n\nTo install the module, use this command from within Julia:\n\n\njulia\n Pkg.clone(\nhttps://github.com/carlobaldassi/RRRMC.jl\n)\n\n\n\n\nDependencies will be installed automatically.\n\n\n\n\nUsage\n\n\nThe module is loaded as any other Julia module:\n\n\njulia\n using RRRMC\n\n\n\n\nThe module provides three functions which implement Monte Carlo Markov Chain algorithms on Ising spin models:\n\n\n\n\nstandardMC\n: a standard Metropolis-Hastings sampler\n\n\nrrrMC\n: the reduced-rejection-rate (RRR) method\n\n\nbklMC\n: the Bortz-Kalos-Lebowitz (BKL) method\n\n\n\n\nThe interface for these three algorithms is documented in the \nSampling algorithms\n page, and it is essentially identical: they take as arguments a graph, an inverse temperature parameter \n\u03b2\n, and the number of Monte Carlo iterations to perform. However, \nrrrMC\n and \nbklMC\n can only be used on some type of models, see the \nGraph types\n page.\n\n\nThese functions allow accessing the internal state during the iteration at regular intervals, via the \nhook\n keyword argument. They also return the final configuration of the system, which is stored in an object of type \nConfig\n.\n\n\nThe code comes with some \nbuilt-in graphs\n, but provides an \ninterface\n to write user-defined models.\n\n\n\n\nNote\n\n\n\n\nThe three sampling functions are the only names exported by the module;\nall other function and types must be qualified with the `RRRMC` module\nname.\n\n\n\n\n\n\nManual\n\n\n\n\nSampling algorithms\n\n\nGraph types\n\n\nBuilt-in graphs\n\n\nSpin glass models\n\n\nRandom regular graphs\n\n\nEdwards-Anderson graphs\n\n\np-spin\n\n\nQuantum models with transverse fields\n\n\n\n\n\n\nTrivial models used for testing and debugging\n\n\n\n\n\n\nGraphs interface\n\n\nFunctions used by all graph types\n\n\nFunctions used by \nDiscrGraph\n models\n\n\nFunctions used by \nDoubleGraph\n models\n\n\nFunctions specific to quantum models", 
            "title": "Home"
        }, 
        {
            "location": "/#rrrmcjl-documentation", 
            "text": "This package implements the Reduced-Rejection-Rate (RRR) Monte Carlo method for Ising spin models described in the paper \"A method to reduce the rejection rate in Monte Carlo Markov Chains on Ising spin models\" by C. Baldassi.  It also provides a standard Metropolis-Hastings sampler, and an implementation of the BKL method described in the paper  \"A new algorithm for Monte Carlo simulation of Ising spin systems\"  by A.B. Bortz, M.H. Kalos and J.L. Lebowitz  The code is written in  Julia , and tested against Julia  0.4 ,  0.5  and  current   0.6-dev  on Linux, OS X, and Windows.", 
            "title": "RRRMC.jl documentation"
        }, 
        {
            "location": "/#installation", 
            "text": "To install the module, use this command from within Julia:  julia  Pkg.clone( https://github.com/carlobaldassi/RRRMC.jl )  Dependencies will be installed automatically.", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "The module is loaded as any other Julia module:  julia  using RRRMC  The module provides three functions which implement Monte Carlo Markov Chain algorithms on Ising spin models:   standardMC : a standard Metropolis-Hastings sampler  rrrMC : the reduced-rejection-rate (RRR) method  bklMC : the Bortz-Kalos-Lebowitz (BKL) method   The interface for these three algorithms is documented in the  Sampling algorithms  page, and it is essentially identical: they take as arguments a graph, an inverse temperature parameter  \u03b2 , and the number of Monte Carlo iterations to perform. However,  rrrMC  and  bklMC  can only be used on some type of models, see the  Graph types  page.  These functions allow accessing the internal state during the iteration at regular intervals, via the  hook  keyword argument. They also return the final configuration of the system, which is stored in an object of type  Config .  The code comes with some  built-in graphs , but provides an  interface  to write user-defined models.   Note   The three sampling functions are the only names exported by the module;\nall other function and types must be qualified with the `RRRMC` module\nname.", 
            "title": "Usage"
        }, 
        {
            "location": "/#manual", 
            "text": "Sampling algorithms  Graph types  Built-in graphs  Spin glass models  Random regular graphs  Edwards-Anderson graphs  p-spin  Quantum models with transverse fields    Trivial models used for testing and debugging    Graphs interface  Functions used by all graph types  Functions used by  DiscrGraph  models  Functions used by  DoubleGraph  models  Functions specific to quantum models", 
            "title": "Manual"
        }, 
        {
            "location": "/algorithms/", 
            "text": "Sampling algorithms\n\n\n#\n\n\nRRRMC.standardMC\n \n \nFunction\n.\n\n\nstandardMC(X::AbstractGraph, \u03b2::Real, iters::Integer; keywords...)\n\n\n\n\nRuns \niters\n iterations of a standard Metropolis Monte Carlo algorithm on the given Ising spin model \nX\n, at inverse temperature \n\u03b2\n. Each spin flip attempt counts as an iteration.\n\n\nReturns two objects: a vector of energies and the last configuration (see \nConfig\n).\n\n\nPossible keyord arguments are:\n\n\n\n\nstep\n: the interval of iterations with which to collect energies (for the returned result) and to call the \nhook\n function (see below).   The default is \n1\n, which is good for debugging but otherwise generally a bad idea.\n\n\nseed\n: the random seed. The default is some arbitrary number.\n\n\nC0\n: the initial configuration. The default is \nnothing\n, in which case it is initialized at random. Otherwise it can be a \nConfig\n object.   Passing the result of a previous run can be useful e.g. when implementing a simulated annealing protocol, or if the system has not equilibrated yet.\n\n\nhook\n: a function to be executed after every \nstep\n number of iterations (see above). It must take five arguments: the current iteration, the graph \nX\n,   the current configuration, the number of accepted moves so far, and the current energy. Useful to collect data other than the energy, write to files ecc;   you'd probably want to use a closure, see the example below. The default is a no-op.\n\n\n\n\nBasic example:\n\n\njulia\n srand(76543); X = RRRMC.GraphPSpin3(3999, 5); \u03b2 = 1.0;\njulia\n Es, C = standardMC(X, \u03b2, 100_000, step = 1_000);\n\n\n\n\nExample of using the \nhook\n for collecting samples as the columns of a \nBitMatrix\n:\n\n\njulia\n iters = 100_000; step = 1_000; l = iters \u00f7 step; N = RRRMC.getN(X);\njulia\n Cs = BitArray(N, l); hook = (it, X, C, acc, E) -\n (Cs[:,it\u00f7step]=C.s);\njulia\n Es, C = standardMC(X, \u03b2, iters, step = step, hook = hook);\n\n\n\n\n#\n\n\nRRRMC.rrrMC\n \n \nFunction\n.\n\n\nrrrMC(X::AbstractGraph, \u03b2::Real, iters::Integer; keywords...)\n\n\n\n\nSame as \nstandardMC\n, but uses the reduced-rejection-rate method. Each iteration takes moretime, but has a higher chance of being accepted, so fewer iterations overall should be needed normally. Whether this trade-off is convenient depends on the parameters and the details of the model.\n\n\nThe return values and the keyword arguments are the same as \nstandardMC\n, see the usage examples for that function. Note however that this function can only be used with \nDiscrGraph\n or \nDoubleGraph\n models.\n\n\n#\n\n\nRRRMC.bklMC\n \n \nFunction\n.\n\n\nbklMC(X::DiscrGraph, \u03b2::Real, iters::Integer; keywords...)\n\n\n\n\nSame as \nstandardMC\n, but uses the rejection-free method by Bortz, Kalos and Lebowitz. Each step takes more, but rejected moves are essentially free, since they are skipped entirely.\n\n\nThe return values and the keyword arguments are the same as \nstandardMC\n, see the usage examples for that function. Note however that this function can only be used with \nDiscrGraph\n models.\n\n\nNote that the number of iterations includes the rejected moves. This makes the results directly comparable with those of \nstandardMC\n. It also means that increasing \n\u03b2\n at fixed \niters\n will result in fewer steps being actually computed.\n\n\n#\n\n\nRRRMC.Interface.Config\n \n \nType\n.\n\n\nConfig(N::Integer)\n\n\n\n\nThe object storing the configuration for an Ising model. Although the spin values are $\u03c3_i \u2208 {-1,1}$, internally they are stored in a \nBitArray\n, in the type field \ns\n, so that to obtain the real value one needs to perform the transformation $\u03c3_i = 2s_i - 1$.", 
            "title": "Sampling Algorithms"
        }, 
        {
            "location": "/algorithms/#sampling-algorithms", 
            "text": "#  RRRMC.standardMC     Function .  standardMC(X::AbstractGraph, \u03b2::Real, iters::Integer; keywords...)  Runs  iters  iterations of a standard Metropolis Monte Carlo algorithm on the given Ising spin model  X , at inverse temperature  \u03b2 . Each spin flip attempt counts as an iteration.  Returns two objects: a vector of energies and the last configuration (see  Config ).  Possible keyord arguments are:   step : the interval of iterations with which to collect energies (for the returned result) and to call the  hook  function (see below).   The default is  1 , which is good for debugging but otherwise generally a bad idea.  seed : the random seed. The default is some arbitrary number.  C0 : the initial configuration. The default is  nothing , in which case it is initialized at random. Otherwise it can be a  Config  object.   Passing the result of a previous run can be useful e.g. when implementing a simulated annealing protocol, or if the system has not equilibrated yet.  hook : a function to be executed after every  step  number of iterations (see above). It must take five arguments: the current iteration, the graph  X ,   the current configuration, the number of accepted moves so far, and the current energy. Useful to collect data other than the energy, write to files ecc;   you'd probably want to use a closure, see the example below. The default is a no-op.   Basic example:  julia  srand(76543); X = RRRMC.GraphPSpin3(3999, 5); \u03b2 = 1.0;\njulia  Es, C = standardMC(X, \u03b2, 100_000, step = 1_000);  Example of using the  hook  for collecting samples as the columns of a  BitMatrix :  julia  iters = 100_000; step = 1_000; l = iters \u00f7 step; N = RRRMC.getN(X);\njulia  Cs = BitArray(N, l); hook = (it, X, C, acc, E) -  (Cs[:,it\u00f7step]=C.s);\njulia  Es, C = standardMC(X, \u03b2, iters, step = step, hook = hook);  #  RRRMC.rrrMC     Function .  rrrMC(X::AbstractGraph, \u03b2::Real, iters::Integer; keywords...)  Same as  standardMC , but uses the reduced-rejection-rate method. Each iteration takes moretime, but has a higher chance of being accepted, so fewer iterations overall should be needed normally. Whether this trade-off is convenient depends on the parameters and the details of the model.  The return values and the keyword arguments are the same as  standardMC , see the usage examples for that function. Note however that this function can only be used with  DiscrGraph  or  DoubleGraph  models.  #  RRRMC.bklMC     Function .  bklMC(X::DiscrGraph, \u03b2::Real, iters::Integer; keywords...)  Same as  standardMC , but uses the rejection-free method by Bortz, Kalos and Lebowitz. Each step takes more, but rejected moves are essentially free, since they are skipped entirely.  The return values and the keyword arguments are the same as  standardMC , see the usage examples for that function. Note however that this function can only be used with  DiscrGraph  models.  Note that the number of iterations includes the rejected moves. This makes the results directly comparable with those of  standardMC . It also means that increasing  \u03b2  at fixed  iters  will result in fewer steps being actually computed.  #  RRRMC.Interface.Config     Type .  Config(N::Integer)  The object storing the configuration for an Ising model. Although the spin values are $\u03c3_i \u2208 {-1,1}$, internally they are stored in a  BitArray , in the type field  s , so that to obtain the real value one needs to perform the transformation $\u03c3_i = 2s_i - 1$.", 
            "title": "Sampling algorithms"
        }, 
        {
            "location": "/graph-types/", 
            "text": "Graph types\n\n\nAll graphs which can be used with the \nsampling algorithms\n belong to a type hierarchy. At the top of the hierarchy, there is \nAbstractGraph\n:\n\n\n#\n\n\nRRRMC.Interface.AbstractGraph\n \n \nType\n.\n\n\nAbstractGraph{ET\n:Real}\n\n\n\n\nAn abstract type representing an Ising spin model. The \nET\n parameter is the type returned by the \nenergy\n and \ndelta_energy\n functions.\n\n\nSee also \nSimpleGraph\n, \nDiscrGraph\n and \nDoubleGraph\n.\n\n\nThere are currently three abstract subclasses, which determine which sampling algorithms can be used:\n\n\n#\n\n\nRRRMC.Interface.SimpleGraph\n \n \nType\n.\n\n\nSimpleGraph{ET} \n: AbstractGraph{ET}\n\n\n\n\nAn abstract type representing a generic graph. This can only be used with \nstandardMC\n, not with \nrrrMC\n or \nbklMC\n.\n\n\nThe \nET\n parameter is the type returned by \nenergy\n and \ndelta_energy\n.\n\n\n#\n\n\nRRRMC.Interface.DiscrGraph\n \n \nType\n.\n\n\nDiscrGraph{ET} \n: AbstractGraph{ET}\n\n\n\n\nAn abstract type representing a graph in which the \ndelta_energy\n values produced when flipping a spin belong to a finite discrete set, and thus can be sampled efficiently with \nrrrMC\n or \nbklMC\n.\n\n\nThe \nET\n parameter is the type returned by \nenergy\n and \ndelta_energy\n.\n\n\nIt is also used internally in \nDoubleGraph\n.\n\n\nSee also \nneighbors\n and \nall\u0394E\n.\n\n\n#\n\n\nRRRMC.Interface.DoubleGraph\n \n \nType\n.\n\n\nDoubleGraph{ET} \n: AbstractGraph{ET}\n\n\n\n\nAn abstract type representing a graph in which the energy is the sum of two contributions, one of which can be encoded in a \nDiscrGraph\n type. This allows \nrrrMC\n to sample values more efficiently.\n\n\nThe \nET\n parameter is the type returned by the \nenergy\n and \ndelta_energy\n functions. Note that it can be different from the type of the internal \nDiscrGraph\n object (e.g., one can have a \nDiscrGraph{Int}\n object inside a \nDoubleGraph{Float64}\n object).\n\n\nSee also \ndiscr_graph\n, \ndelta_energy_residual\n and \nupdate_cache_residual!\n.", 
            "title": "Graph Types"
        }, 
        {
            "location": "/graph-types/#graph-types", 
            "text": "All graphs which can be used with the  sampling algorithms  belong to a type hierarchy. At the top of the hierarchy, there is  AbstractGraph :  #  RRRMC.Interface.AbstractGraph     Type .  AbstractGraph{ET :Real}  An abstract type representing an Ising spin model. The  ET  parameter is the type returned by the  energy  and  delta_energy  functions.  See also  SimpleGraph ,  DiscrGraph  and  DoubleGraph .  There are currently three abstract subclasses, which determine which sampling algorithms can be used:  #  RRRMC.Interface.SimpleGraph     Type .  SimpleGraph{ET}  : AbstractGraph{ET}  An abstract type representing a generic graph. This can only be used with  standardMC , not with  rrrMC  or  bklMC .  The  ET  parameter is the type returned by  energy  and  delta_energy .  #  RRRMC.Interface.DiscrGraph     Type .  DiscrGraph{ET}  : AbstractGraph{ET}  An abstract type representing a graph in which the  delta_energy  values produced when flipping a spin belong to a finite discrete set, and thus can be sampled efficiently with  rrrMC  or  bklMC .  The  ET  parameter is the type returned by  energy  and  delta_energy .  It is also used internally in  DoubleGraph .  See also  neighbors  and  all\u0394E .  #  RRRMC.Interface.DoubleGraph     Type .  DoubleGraph{ET}  : AbstractGraph{ET}  An abstract type representing a graph in which the energy is the sum of two contributions, one of which can be encoded in a  DiscrGraph  type. This allows  rrrMC  to sample values more efficiently.  The  ET  parameter is the type returned by the  energy  and  delta_energy  functions. Note that it can be different from the type of the internal  DiscrGraph  object (e.g., one can have a  DiscrGraph{Int}  object inside a  DoubleGraph{Float64}  object).  See also  discr_graph ,  delta_energy_residual  and  update_cache_residual! .", 
            "title": "Graph types"
        }, 
        {
            "location": "/graphs-builtin/", 
            "text": "Built-in graphs\n\n\nFollowing is the list of the graph models which are provided with the module. After loading the \nRRRMC\n module, they can be constructed like in this example:\n\n\njulia\n X = RRRMC.GraphRRG(10, 3)\n\n\n\n\nNote that for models which involve randomness in the constructor you may want to set the random seed with \nsrand\n before calling the constructor, for reproducibility purposes.\n\n\n\n\nSpin glass models\n\n\n\n\nRandom regular graphs\n\n\n#\n\n\nRRRMC.RRG.GraphRRG\n \n \nType\n.\n\n\nGraphRRG(N::Integer, K::Integer, LEV = (-1,1)) \n: DiscrGraph\n\n\n\n\nA \nDiscGraph\n implementing a random regular graph with \nN\n spins and connectivity \nK\n. \nNote\n: \nN*K\n must be even. Also, the graph generator uses the pairing model method by Bollob\u00e1s, with a cutoff on the number of restarts, and thus it may occasionally fail if \nK\n is large. The interactions are extracted at random from \nLEV\n, which must be a \nTuple\n of \nReal\ns. No external fields.\n\n\n#\n\n\nRRRMC.RRG.GraphRRGCont\n \n \nType\n.\n\n\nGraphRRGCont(N::Integer, K::Integer, LEV) \n: DoubleGraph{Float64}\n\n\n\n\nA \nDoubleGraph\n implementing a random regular graph with \nN\n spins and connectivity \nK\n. \nNote\n: \nN*K\n must be even. Also, the graph generator uses the pairing model method by Bollob\u00e1s, with a cutoff on the number of restarts, and thus it may occasionally fail if \nK\n is large. The interactions are extracted from a normal distribution with unit variance, and are then discretized using the values in \nLEV\n, which must be a \nTuple\n of \nReal\ns. No external fields.\n\n\nSame as \nGraphRRGContSimple\n, but it can be used with \nrrrMC\n.\n\n\n#\n\n\nRRRMC.RRG.GraphRRGContSimple\n \n \nType\n.\n\n\nGraphRRGContSimple(N::Integer, K::Integer) \n: SimpleGraph{Flaot64}\n\n\n\n\nA \nSimpleGraph\n implementing a random regular graph with \nN\n spins and connectivity \nK\n. \nNote\n: \nN*K\n must be even. Also, the graph generator uses the pairing model method by Bollob\u00e1s, with a cutoff on the number of restarts, and thus it may occasionally fail if \nK\n is large. The interactions are extracted from a normal distribution with unit variance.\n\n\nSame as \nGraphRRGCont\n, but it's more efficient when used with \nstandardMC\n.\n\n\n\n\nEdwards-Anderson graphs\n\n\n#\n\n\nRRRMC.EA.GraphEA\n \n \nType\n.\n\n\nGraphEA(L::Integer, D::Integer, LEV = (-1,1)) \n: DiscrGraph\n\n\n\n\nAn Edwards-Anderson \nDiscrGraph\n: spins are arranged on a square lattice of size \nL\n in \nD\n dimensions (i.e. there are $L^D$ total spins), with periodic boundary conditions. The interactions are extracted at random from \nLEV\n, which must be a \nTuple\n of \nReal\ns. No external fields.\n\n\n#\n\n\nRRRMC.EA.GraphEACont\n \n \nType\n.\n\n\nGraphEACont(L::Integer, D::Integer, LEV) \n: DoubleGraph{Float64}\n\n\n\n\nAn Edwards-Anderson \nDoubleGraph\n: spins are arranged on a square lattice of size \nL\n in \nD\n dimensions (i.e. there are $L^D$ total spins), with periodic boundary conditions. The interactions are extracted at random from a normal distribution with unit variance, and are then discretized using the values in \nLEV\n, which must be a \nTuple\n of \nReal\ns. No external fields.\n\n\nSame as \nGraphEAContSimple\n, but it can be used with \nrrrMC\n.\n\n\n#\n\n\nRRRMC.EA.GraphEAContSimple\n \n \nType\n.\n\n\nGraphEACont(L::Integer, D::Integer) \n: SimpleGraph{Float64}\n\n\n\n\nAn Edwards-Anderson \nSimpleGraph\n: spins are arranged on a square lattice of size \nL\n in \nD\n dimensions (i.e. there are $L^D$ total spins), with periodic boundary conditions. The interactions are extracted at random from a normal distribution with unit variance.\n\n\nSame as \nGraphEACont\n, but it's more efficient when used with \nstandardMC\n.\n\n\n\n\np-spin\n\n\n#\n\n\nRRRMC.PSpin3.GraphPSpin3\n \n \nType\n.\n\n\nGraphPSpin3(N::Integer, K::Integer) \n: DiscrGraph\n\n\n\n\nA \nDiscrGraph\n implementing a \np\n-spin regular graph with \np=3\n. \nN\n is the number of spins, and must be divisible by \n3\n; \nK\n is the connectivity. All interactions are set to $J=1$.\n\n\n\n\nQuantum models with transverse fields\n\n\n#\n\n\nRRRMC.QIsingT.GraphQIsingT\n \n \nType\n.\n\n\nGraphQIsingT(N::Integer, M::Integer, \u0393::Float64, \u03b2::Float64) \n: DoubleGraph\n\n\n\n\nA \nDoubleGraph\n which implements a quantum Ising spin model in a transverse magnetic field, using the Suzuki-Trotter transformation. \nN\n is the number of spins, \nM\n the number of Suzuki-Trotter replicas, \n\u0393\n the transverse field, \n\u03b2\n the inverse temperature. The graph is fully-connected, the interactions are random ($J \u2208 {-1,1}$), there are no external longitudinal fields.\n\n\nSee also \nQenergy\n.\n\n\n\n\nTrivial models used for testing and debugging\n\n\n#\n\n\nRRRMC.TwoSpin.GraphTwoSpin\n \n \nType\n.\n\n\nGraphTwoSpin() \n: DiscrGraph\n\n\n\n\nA trivial \nDiscrGraph\n type with 2 spins inteacting ferromagnetically ($J=1$), without fields.\n\n\nOnly useful for testing/debugging purposes.\n\n\n#\n\n\nRRRMC.ThreeSpin.GraphThreeSpin\n \n \nType\n.\n\n\nGraphThreeSpin() \n: DiscrGraph\n\n\n\n\nA trivial \nDiscrGraph\n type with 3 spins, ferromagnetic interactions ($J=1$), no fields, and periodic boundary conditions.\n\n\nOnly useful for testing/debugging purposes.\n\n\n#\n\n\nRRRMC.Fields.GraphFields\n \n \nType\n.\n\n\nGraphFields(N::Integer, LEV::Tuple = (1,)) \n: DiscrGraph\n\n\n\n\nA simple \nDiscrGraph\n type with \nN\n non-interacting variables, each of which is subject to a local field. The fields are extracted at random from \nLEV\n, which must be a \nTuple\n of \nReal\ns.\n\n\nMostly useful for testing/debugging purposes.\n\n\n#\n\n\nRRRMC.Fields.GraphFieldsCont\n \n \nType\n.\n\n\nGraphFieldsCont(N::Integer, LEV::Tuple) \n: DoubleGraph\n\n\n\n\nA simple \nDoubleGraph\n type with \nN\n non-interacting variables, each of which is subject to a local field. The fields are extracted independently from a normal distribution with unit variance, and then are discretized using the values in \nLEV\n, which must be a \nTuple\n of \nReal\ns.\n\n\nMostly useful for testing/debugging purposes.\n\n\n#\n\n\nRRRMC.Ising1D.GraphIsing1D\n \n \nType\n.\n\n\nGraphIsing1D(N::Integer) \n: DiscrGraph\n\n\n\n\nA simple 1-dimensional \nDiscrGraph\n type with \nN\n spins, antiferromagnetic interactions ($J=-1$), no fields, and periodic boundary conditions.\n\n\nMostly useful for testing/debugging purposes.\n\n\n#\n\n\nRRRMC.Q0T.GraphQ0T\n \n \nType\n.\n\n\nGraphQ0T(N::Integer, M::Integer, \u0393::Float64, \u03b2::Float64) \n: DoubleGraph\n\n\n\n\nA simple \nDoubleGraph\n which implements independent spins in a transverse magnetic field, using the Suzuki-Trotter transformation. \nN\n is the number of spins, \nM\n the number of Suzuki-Trotter replicas, \n\u0393\n the transverse field, \n\u03b2\n the inverse temperature.\n\n\nIntended for testing/debugging purposes.\n\n\nSee also \nQenergy\n.", 
            "title": "Built-in Graphs"
        }, 
        {
            "location": "/graphs-builtin/#built-in-graphs", 
            "text": "Following is the list of the graph models which are provided with the module. After loading the  RRRMC  module, they can be constructed like in this example:  julia  X = RRRMC.GraphRRG(10, 3)  Note that for models which involve randomness in the constructor you may want to set the random seed with  srand  before calling the constructor, for reproducibility purposes.", 
            "title": "Built-in graphs"
        }, 
        {
            "location": "/graphs-builtin/#spin-glass-models", 
            "text": "", 
            "title": "Spin glass models"
        }, 
        {
            "location": "/graphs-builtin/#random-regular-graphs", 
            "text": "#  RRRMC.RRG.GraphRRG     Type .  GraphRRG(N::Integer, K::Integer, LEV = (-1,1))  : DiscrGraph  A  DiscGraph  implementing a random regular graph with  N  spins and connectivity  K .  Note :  N*K  must be even. Also, the graph generator uses the pairing model method by Bollob\u00e1s, with a cutoff on the number of restarts, and thus it may occasionally fail if  K  is large. The interactions are extracted at random from  LEV , which must be a  Tuple  of  Real s. No external fields.  #  RRRMC.RRG.GraphRRGCont     Type .  GraphRRGCont(N::Integer, K::Integer, LEV)  : DoubleGraph{Float64}  A  DoubleGraph  implementing a random regular graph with  N  spins and connectivity  K .  Note :  N*K  must be even. Also, the graph generator uses the pairing model method by Bollob\u00e1s, with a cutoff on the number of restarts, and thus it may occasionally fail if  K  is large. The interactions are extracted from a normal distribution with unit variance, and are then discretized using the values in  LEV , which must be a  Tuple  of  Real s. No external fields.  Same as  GraphRRGContSimple , but it can be used with  rrrMC .  #  RRRMC.RRG.GraphRRGContSimple     Type .  GraphRRGContSimple(N::Integer, K::Integer)  : SimpleGraph{Flaot64}  A  SimpleGraph  implementing a random regular graph with  N  spins and connectivity  K .  Note :  N*K  must be even. Also, the graph generator uses the pairing model method by Bollob\u00e1s, with a cutoff on the number of restarts, and thus it may occasionally fail if  K  is large. The interactions are extracted from a normal distribution with unit variance.  Same as  GraphRRGCont , but it's more efficient when used with  standardMC .", 
            "title": "Random regular graphs"
        }, 
        {
            "location": "/graphs-builtin/#edwards-anderson-graphs", 
            "text": "#  RRRMC.EA.GraphEA     Type .  GraphEA(L::Integer, D::Integer, LEV = (-1,1))  : DiscrGraph  An Edwards-Anderson  DiscrGraph : spins are arranged on a square lattice of size  L  in  D  dimensions (i.e. there are $L^D$ total spins), with periodic boundary conditions. The interactions are extracted at random from  LEV , which must be a  Tuple  of  Real s. No external fields.  #  RRRMC.EA.GraphEACont     Type .  GraphEACont(L::Integer, D::Integer, LEV)  : DoubleGraph{Float64}  An Edwards-Anderson  DoubleGraph : spins are arranged on a square lattice of size  L  in  D  dimensions (i.e. there are $L^D$ total spins), with periodic boundary conditions. The interactions are extracted at random from a normal distribution with unit variance, and are then discretized using the values in  LEV , which must be a  Tuple  of  Real s. No external fields.  Same as  GraphEAContSimple , but it can be used with  rrrMC .  #  RRRMC.EA.GraphEAContSimple     Type .  GraphEACont(L::Integer, D::Integer)  : SimpleGraph{Float64}  An Edwards-Anderson  SimpleGraph : spins are arranged on a square lattice of size  L  in  D  dimensions (i.e. there are $L^D$ total spins), with periodic boundary conditions. The interactions are extracted at random from a normal distribution with unit variance.  Same as  GraphEACont , but it's more efficient when used with  standardMC .", 
            "title": "Edwards-Anderson graphs"
        }, 
        {
            "location": "/graphs-builtin/#p-spin", 
            "text": "#  RRRMC.PSpin3.GraphPSpin3     Type .  GraphPSpin3(N::Integer, K::Integer)  : DiscrGraph  A  DiscrGraph  implementing a  p -spin regular graph with  p=3 .  N  is the number of spins, and must be divisible by  3 ;  K  is the connectivity. All interactions are set to $J=1$.", 
            "title": "p-spin"
        }, 
        {
            "location": "/graphs-builtin/#quantum-models-with-transverse-fields", 
            "text": "#  RRRMC.QIsingT.GraphQIsingT     Type .  GraphQIsingT(N::Integer, M::Integer, \u0393::Float64, \u03b2::Float64)  : DoubleGraph  A  DoubleGraph  which implements a quantum Ising spin model in a transverse magnetic field, using the Suzuki-Trotter transformation.  N  is the number of spins,  M  the number of Suzuki-Trotter replicas,  \u0393  the transverse field,  \u03b2  the inverse temperature. The graph is fully-connected, the interactions are random ($J \u2208 {-1,1}$), there are no external longitudinal fields.  See also  Qenergy .", 
            "title": "Quantum models with transverse fields"
        }, 
        {
            "location": "/graphs-builtin/#trivial-models-used-for-testing-and-debugging", 
            "text": "#  RRRMC.TwoSpin.GraphTwoSpin     Type .  GraphTwoSpin()  : DiscrGraph  A trivial  DiscrGraph  type with 2 spins inteacting ferromagnetically ($J=1$), without fields.  Only useful for testing/debugging purposes.  #  RRRMC.ThreeSpin.GraphThreeSpin     Type .  GraphThreeSpin()  : DiscrGraph  A trivial  DiscrGraph  type with 3 spins, ferromagnetic interactions ($J=1$), no fields, and periodic boundary conditions.  Only useful for testing/debugging purposes.  #  RRRMC.Fields.GraphFields     Type .  GraphFields(N::Integer, LEV::Tuple = (1,))  : DiscrGraph  A simple  DiscrGraph  type with  N  non-interacting variables, each of which is subject to a local field. The fields are extracted at random from  LEV , which must be a  Tuple  of  Real s.  Mostly useful for testing/debugging purposes.  #  RRRMC.Fields.GraphFieldsCont     Type .  GraphFieldsCont(N::Integer, LEV::Tuple)  : DoubleGraph  A simple  DoubleGraph  type with  N  non-interacting variables, each of which is subject to a local field. The fields are extracted independently from a normal distribution with unit variance, and then are discretized using the values in  LEV , which must be a  Tuple  of  Real s.  Mostly useful for testing/debugging purposes.  #  RRRMC.Ising1D.GraphIsing1D     Type .  GraphIsing1D(N::Integer)  : DiscrGraph  A simple 1-dimensional  DiscrGraph  type with  N  spins, antiferromagnetic interactions ($J=-1$), no fields, and periodic boundary conditions.  Mostly useful for testing/debugging purposes.  #  RRRMC.Q0T.GraphQ0T     Type .  GraphQ0T(N::Integer, M::Integer, \u0393::Float64, \u03b2::Float64)  : DoubleGraph  A simple  DoubleGraph  which implements independent spins in a transverse magnetic field, using the Suzuki-Trotter transformation.  N  is the number of spins,  M  the number of Suzuki-Trotter replicas,  \u0393  the transverse field,  \u03b2  the inverse temperature.  Intended for testing/debugging purposes.  See also  Qenergy .", 
            "title": "Trivial models used for testing and debugging"
        }, 
        {
            "location": "/interface/", 
            "text": "Graphs interface\n\n\nThis page contains all the functions which are needed when implementing a \ngraph type\n. See the \nbuilt-in graphs\n for concrete examples (in particular, the RRG and EA family of graphs have the most complete implementations). See also the documentation for the \nConfig\n type.\n\n\n\n\nFunctions used by all graph types\n\n\n#\n\n\nRRRMC.Interface.energy\n \n \nFunction\n.\n\n\nenergy(X::AbstractGraph, C::Config)\n\n\n\n\nReturns the energy of graph \nX\n in the configuration \nC\n. This is always invoked at the beginning of \nstandardMC\n, \nrrrMC\n and \nbklMC\n. Subsequently, \ndelta_energy\n is used instead.\n\n\nAll graphs must implement this function.\n\n\nIt should also be used to initialize/reset the cache for a given graph, if any (see \nupdate_cache!\n).\n\n\n#\n\n\nRRRMC.Interface.delta_energy\n \n \nFunction\n.\n\n\ndelta_energy(X::AbstractGraph, C::Config, move::Int)\n\n\n\n\nReturns the energy difference that would be associated to flipping the spin \nmove\n.\n\n\nA default fallback implementation based on \nenergy\n is provided, to be used for debugging, but having an efficient implementation for each graph is critical for performance.\n\n\nNote\n: when \nX\n is a \nDiscrGraph\n, the absolute value of the result must be contained in the tuple returned by \nall\u0394E\n \u2013 no approximations are allowed, and missing values will cause crashes (unless Julia is run with the \n--check-bounds=yes\n option, in which case they will cause errors).\n\n\nNote\n: this function is always invoked \nbefore\n performing the flip, unlike in \nupdate_cache!\n and \nupdate_cache_residual!\n.\n\n\n#\n\n\nRRRMC.Interface.update_cache!\n \n \nFunction\n.\n\n\nupdate_cache!(X::AbstractGraph, C::Config, move::Int)\n\n\n\n\nA function which is called every time a spin is flipped. This may happen:\n\n\n\n\nwhen a move is accepted, in \nstandardMC\n, \nrrrMC\n and \nbklMC\n\n\nwhen a move is attempted to evaluate the effect on the neighbors, in \nrrrMC\n.\n\n\n\n\nmove\n is the spin index. By default, this function does nothing, but it may be overloaded by particular graph types.\n\n\nWhen \nX\n is a \nDoubleGraph\n, there is a default implementation which first calls \nupdate_cache!\n on \ndiscr_graph\n(X)\n, then calls \nupdate_cache_residual!\n on \nX\n.\n\n\nNote\n: this function is always invoked \nafter\n the flip has been performed, unlike in \ndelta_energy\n and \ndelta_energy_residual\n.\n\n\n#\n\n\nRRRMC.Interface.getN\n \n \nFunction\n.\n\n\ngetN(X::AbstractGraph)\n\n\n\n\nReturns the number of spins for a graph. The default implementation just returns \nX.N\n.\n\n\n\n\nFunctions used by \nDiscrGraph\n models\n\n\n#\n\n\nRRRMC.Interface.neighbors\n \n \nFunction\n.\n\n\nneighbors(X::DiscrGraph, i::Int)\n\n\n\n\nReturns an iterable with all the neighbors of spin \ni\n. This is required by \nrrrMC\n and \nbklMC\n since those methods need to evaluate the effect of flipping a spin on its neighbors' delta-energy classes.\n\n\nFor performance reasons, it is best if the returned value is stack-allocated rather than heap-allocated, e.g. it is better to return a \nTuple\n than a \nVector\n.\n\n\n#\n\n\nRRRMC.Interface.all\u0394E\n \n \nFunction\n.\n\n\nall\u0394E{P\n:DiscrGraph}(::Type{P})\n\n\n\n\nReturns a tuple of all possible \nnon-negative\n values that can be returned by \ndelta_energy\n. This must be implemented by all \nDiscrGraph\n objects in order to use \nrrrMC\n or \nbklMC\n.\n\n\nFor performance reasons, it is best if the result can be computed from the type of the graph alone (possibly using a generated function).\n\n\n\n\nFunctions used by \nDoubleGraph\n models\n\n\n#\n\n\nRRRMC.Interface.discr_graph\n \n \nFunction\n.\n\n\ndiscr_graph(X::DoubleGraph)\n\n\n\n\nReturns the internal \nDiscrGraph\n used by the given \nDoubleGraph\n. The default implementation simply returns \nX.X0\n.\n\n\n#\n\n\nRRRMC.Interface.delta_energy_residual\n \n \nFunction\n.\n\n\ndelta_energy_residual(X::DoubleGraph, C::Config, move::Int)\n\n\n\n\nReturns the residual part of the energy difference produced if the spin \nmove\n would be flipped, excluding the contribution from the internal \nDiscrGraph\n (see \ndiscr_graph\n).\n\n\nSee also \ndelta_energy\n. There is a default fallback implementation, but it should be overloaded for efficiency.\n\n\n#\n\n\nRRRMC.Interface.update_cache_residual!\n \n \nFunction\n.\n\n\nupdate_cache_residual!(X::DoubleGraph, C::Config, move::Int)\n\n\n\n\nCalled internally by the default \nupdate_cache!\n when the argument is a \nDoubleGraph\n. Can be useful to overload this if the residual part of the graph has an indipendent cache.\n\n\nBy default, it does nothing.\n\n\n\n\nFunctions specific to quantum models\n\n\n#\n\n\nRRRMC.QT.Qenergy\n \n \nFunction\n.\n\n\nQenergy(X::DoubleGraph, C::Config)\n\n\n\n\nWhen using the Suzuki-Trotter transformation to simulate quantum systems in a transverse magnetic field with a replicated classical system, this function should be used to obtain the average value of the Hamiltonian observable (divided by the number of spins).\n\n\n#\n\n\nRRRMC.QT.transverse_mag\n \n \nFunction\n.\n\n\ntransverse_mag(X::DoubleGraph, C::Config, \u03b2::Float64)\n\n\n\n\nWhen using the Suzuki-Trotter transformation to simulate quantum systems in a transverse magnetic field with a replicated classical system, this function should be used to obtain the average value of the transverse magnetization observable.", 
            "title": "Graphs Interface"
        }, 
        {
            "location": "/interface/#graphs-interface", 
            "text": "This page contains all the functions which are needed when implementing a  graph type . See the  built-in graphs  for concrete examples (in particular, the RRG and EA family of graphs have the most complete implementations). See also the documentation for the  Config  type.", 
            "title": "Graphs interface"
        }, 
        {
            "location": "/interface/#functions-used-by-all-graph-types", 
            "text": "#  RRRMC.Interface.energy     Function .  energy(X::AbstractGraph, C::Config)  Returns the energy of graph  X  in the configuration  C . This is always invoked at the beginning of  standardMC ,  rrrMC  and  bklMC . Subsequently,  delta_energy  is used instead.  All graphs must implement this function.  It should also be used to initialize/reset the cache for a given graph, if any (see  update_cache! ).  #  RRRMC.Interface.delta_energy     Function .  delta_energy(X::AbstractGraph, C::Config, move::Int)  Returns the energy difference that would be associated to flipping the spin  move .  A default fallback implementation based on  energy  is provided, to be used for debugging, but having an efficient implementation for each graph is critical for performance.  Note : when  X  is a  DiscrGraph , the absolute value of the result must be contained in the tuple returned by  all\u0394E  \u2013 no approximations are allowed, and missing values will cause crashes (unless Julia is run with the  --check-bounds=yes  option, in which case they will cause errors).  Note : this function is always invoked  before  performing the flip, unlike in  update_cache!  and  update_cache_residual! .  #  RRRMC.Interface.update_cache!     Function .  update_cache!(X::AbstractGraph, C::Config, move::Int)  A function which is called every time a spin is flipped. This may happen:   when a move is accepted, in  standardMC ,  rrrMC  and  bklMC  when a move is attempted to evaluate the effect on the neighbors, in  rrrMC .   move  is the spin index. By default, this function does nothing, but it may be overloaded by particular graph types.  When  X  is a  DoubleGraph , there is a default implementation which first calls  update_cache!  on  discr_graph (X) , then calls  update_cache_residual!  on  X .  Note : this function is always invoked  after  the flip has been performed, unlike in  delta_energy  and  delta_energy_residual .  #  RRRMC.Interface.getN     Function .  getN(X::AbstractGraph)  Returns the number of spins for a graph. The default implementation just returns  X.N .", 
            "title": "Functions used by all graph types"
        }, 
        {
            "location": "/interface/#functions-used-by-discrgraph-models", 
            "text": "#  RRRMC.Interface.neighbors     Function .  neighbors(X::DiscrGraph, i::Int)  Returns an iterable with all the neighbors of spin  i . This is required by  rrrMC  and  bklMC  since those methods need to evaluate the effect of flipping a spin on its neighbors' delta-energy classes.  For performance reasons, it is best if the returned value is stack-allocated rather than heap-allocated, e.g. it is better to return a  Tuple  than a  Vector .  #  RRRMC.Interface.all\u0394E     Function .  all\u0394E{P :DiscrGraph}(::Type{P})  Returns a tuple of all possible  non-negative  values that can be returned by  delta_energy . This must be implemented by all  DiscrGraph  objects in order to use  rrrMC  or  bklMC .  For performance reasons, it is best if the result can be computed from the type of the graph alone (possibly using a generated function).", 
            "title": "Functions used by DiscrGraph models"
        }, 
        {
            "location": "/interface/#functions-used-by-doublegraph-models", 
            "text": "#  RRRMC.Interface.discr_graph     Function .  discr_graph(X::DoubleGraph)  Returns the internal  DiscrGraph  used by the given  DoubleGraph . The default implementation simply returns  X.X0 .  #  RRRMC.Interface.delta_energy_residual     Function .  delta_energy_residual(X::DoubleGraph, C::Config, move::Int)  Returns the residual part of the energy difference produced if the spin  move  would be flipped, excluding the contribution from the internal  DiscrGraph  (see  discr_graph ).  See also  delta_energy . There is a default fallback implementation, but it should be overloaded for efficiency.  #  RRRMC.Interface.update_cache_residual!     Function .  update_cache_residual!(X::DoubleGraph, C::Config, move::Int)  Called internally by the default  update_cache!  when the argument is a  DoubleGraph . Can be useful to overload this if the residual part of the graph has an indipendent cache.  By default, it does nothing.", 
            "title": "Functions used by DoubleGraph models"
        }, 
        {
            "location": "/interface/#functions-specific-to-quantum-models", 
            "text": "#  RRRMC.QT.Qenergy     Function .  Qenergy(X::DoubleGraph, C::Config)  When using the Suzuki-Trotter transformation to simulate quantum systems in a transverse magnetic field with a replicated classical system, this function should be used to obtain the average value of the Hamiltonian observable (divided by the number of spins).  #  RRRMC.QT.transverse_mag     Function .  transverse_mag(X::DoubleGraph, C::Config, \u03b2::Float64)  When using the Suzuki-Trotter transformation to simulate quantum systems in a transverse magnetic field with a replicated classical system, this function should be used to obtain the average value of the transverse magnetization observable.", 
            "title": "Functions specific to quantum models"
        }
    ]
}