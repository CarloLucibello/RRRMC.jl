<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Built-in graphs · RRRMC.jl documentation</title><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script></head><body><nav class="toc"><a href><img class="logo" src="assets/logo.png" alt="RRRMC.jl logo"/></a><h1>RRRMC.jl</h1><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="algorithms.html">Sampling algorithms</a></li><li><a class="toctext" href="graph-types.html">Graph types</a></li><li class="current"><a class="toctext" href="graphs-builtin.html">Built-in graphs</a><ul class="internal"><li><a class="toctext" href="#Spin-glass-models-1">Spin glass models</a></li><li><a class="toctext" href="#Trivial-models-used-for-testing-and-debugging-1">Trivial models used for testing and debugging</a></li></ul></li><li><a class="toctext" href="interface.html">Graphs interface</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="graphs-builtin.html">Built-in graphs</a></li></ul><a class="edit-page" href="https://github.com/carlobaldassi/RRRMC.jl/tree/a69e21374f237a36fef162aff0f25e8754bd7de3/docs/src/graphs-builtin.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="builtin-1" href="#builtin-1">Built-in graphs</a></h1><p>Following is the list of the graph models which are provided with the module. After loading the <code>RRRMC</code> module, they can be constructed like in this example:</p><pre><code class="language-text">julia&gt; X = RRRMC.GraphRRG(10, 3)</code></pre><p>Note that for models which involve randomness in the constructor you may want to set the random seed with <code>srand</code> before calling the constructor, for reproducibility purposes.</p><h2><a class="nav-anchor" id="Spin-glass-models-1" href="#Spin-glass-models-1">Spin glass models</a></h2><h3><a class="nav-anchor" id="Random-regular-graphs-1" href="#Random-regular-graphs-1">Random regular graphs</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.RRG.GraphRRG" href="#RRRMC.RRG.GraphRRG"><code>RRRMC.RRG.GraphRRG</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphRRG(N::Integer, K::Integer, LEV = (-1,1)) &lt;: DiscrGraph</code></pre><p>A <code>DiscGraph</code> implementing a random regular graph with <code>N</code> spins and connectivity <code>K</code>. <em>Note</em>: <code>N*K</code> must be even. Also, the graph generator uses the pairing model method by Bollobás, with a cutoff on the number of restarts, and thus it may occasionally fail if <code>K</code> is large. The interactions are extracted at random from <code>LEV</code>, which must be a <code>Tuple</code> of <code>Real</code>s. No external fields.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.RRG.GraphRRGCont" href="#RRRMC.RRG.GraphRRGCont"><code>RRRMC.RRG.GraphRRGCont</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphRRGCont(N::Integer, K::Integer, LEV) &lt;: DoubleGraph{Float64}</code></pre><p>A <code>DoubleGraph</code> implementing a random regular graph with <code>N</code> spins and connectivity <code>K</code>. <em>Note</em>: <code>N*K</code> must be even. Also, the graph generator uses the pairing model method by Bollobás, with a cutoff on the number of restarts, and thus it may occasionally fail if <code>K</code> is large. The interactions are extracted from a normal distribution with unit variance, and are then discretized using the values in <code>LEV</code>, which must be a <code>Tuple</code> of <code>Real</code>s. No external fields.</p><p>Same as <a href="graphs-builtin.html#RRRMC.RRG.GraphRRGContSimple"><code>GraphRRGContSimple</code></a>, but it can be used with <a href="algorithms.html#RRRMC.rrrMC"><code>rrrMC</code></a>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.RRG.GraphRRGContSimple" href="#RRRMC.RRG.GraphRRGContSimple"><code>RRRMC.RRG.GraphRRGContSimple</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphRRGContSimple(N::Integer, K::Integer) &lt;: SimpleGraph{Flaot64}</code></pre><p>A <code>SimpleGraph</code> implementing a random regular graph with <code>N</code> spins and connectivity <code>K</code>. <em>Note</em>: <code>N*K</code> must be even. Also, the graph generator uses the pairing model method by Bollobás, with a cutoff on the number of restarts, and thus it may occasionally fail if <code>K</code> is large. The interactions are extracted from a normal distribution with unit variance.</p><p>Same as <a href="graphs-builtin.html#RRRMC.RRG.GraphRRGCont"><code>GraphRRGCont</code></a>, but it&#39;s more efficient when used with <a href="algorithms.html#RRRMC.standardMC"><code>standardMC</code></a>.</p></div></section><h3><a class="nav-anchor" id="Edwards-Anderson-graphs-1" href="#Edwards-Anderson-graphs-1">Edwards-Anderson graphs</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.EA.GraphEA" href="#RRRMC.EA.GraphEA"><code>RRRMC.EA.GraphEA</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphEA(L::Integer, D::Integer, LEV = (-1,1)) &lt;: DiscrGraph</code></pre><p>An Edwards-Anderson <code>DiscrGraph</code>: spins are arranged on a square lattice of size <code>L</code> in <code>D</code> dimensions (i.e. there are <span>$L^D$</span> total spins), with periodic boundary conditions. The interactions are extracted at random from <code>LEV</code>, which must be a <code>Tuple</code> of <code>Real</code>s. No external fields.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.EA.GraphEACont" href="#RRRMC.EA.GraphEACont"><code>RRRMC.EA.GraphEACont</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphEACont(L::Integer, D::Integer, LEV) &lt;: DoubleGraph{Float64}</code></pre><p>An Edwards-Anderson <code>DoubleGraph</code>: spins are arranged on a square lattice of size <code>L</code> in <code>D</code> dimensions (i.e. there are <span>$L^D$</span> total spins), with periodic boundary conditions. The interactions are extracted at random from a normal distribution with unit variance, and are then discretized using the values in <code>LEV</code>, which must be a <code>Tuple</code> of <code>Real</code>s. No external fields.</p><p>Same as <a href="graphs-builtin.html#RRRMC.EA.GraphEAContSimple"><code>GraphEAContSimple</code></a>, but it can be used with <a href="algorithms.html#RRRMC.rrrMC"><code>rrrMC</code></a>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.EA.GraphEAContSimple" href="#RRRMC.EA.GraphEAContSimple"><code>RRRMC.EA.GraphEAContSimple</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphEACont(L::Integer, D::Integer) &lt;: SimpleGraph{Float64}</code></pre><p>An Edwards-Anderson <code>SimpleGraph</code>: spins are arranged on a square lattice of size <code>L</code> in <code>D</code> dimensions (i.e. there are <span>$L^D$</span> total spins), with periodic boundary conditions. The interactions are extracted at random from a normal distribution with unit variance.</p><p>Same as <a href="graphs-builtin.html#RRRMC.EA.GraphEACont"><code>GraphEACont</code></a>, but it&#39;s more efficient when used with <a href="algorithms.html#RRRMC.standardMC"><code>standardMC</code></a>.</p></div></section><h3><a class="nav-anchor" id="p-spin-1" href="#p-spin-1">p-spin</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.PSpin3.GraphPSpin3" href="#RRRMC.PSpin3.GraphPSpin3"><code>RRRMC.PSpin3.GraphPSpin3</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphPSpin3(N::Integer, K::Integer) &lt;: DiscrGraph</code></pre><p>A <code>DiscrGraph</code> implementing a <code>p</code>-spin regular graph with <code>p=3</code>. <code>N</code> is the number of spins, and must be divisible by <code>3</code>; <code>K</code> is the connectivity. All interactions are set to <span>$J=1$</span>.</p></div></section><h3><a class="nav-anchor" id="Quantum-models-with-transverse-fields-1" href="#Quantum-models-with-transverse-fields-1">Quantum models with transverse fields</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.QIsingT.GraphQIsingT" href="#RRRMC.QIsingT.GraphQIsingT"><code>RRRMC.QIsingT.GraphQIsingT</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphQIsingT(N::Integer, M::Integer, Γ::Float64, β::Float64) &lt;: DoubleGraph</code></pre><p>A <code>DoubleGraph</code> which implements a quantum Ising spin model in a transverse magnetic field, using the Suzuki-Trotter transformation. <code>N</code> is the number of spins, <code>M</code> the number of Suzuki-Trotter replicas, <code>Γ</code> the transverse field, <code>β</code> the inverse temperature. The graph is fully-connected, the interactions are random (<span>$J ∈ {-1,1}$</span>), there are no external longitudinal fields.</p><p>See also <a href="interface.html#RRRMC.QT.Qenergy"><code>Qenergy</code></a>.</p></div></section><h2><a class="nav-anchor" id="Trivial-models-used-for-testing-and-debugging-1" href="#Trivial-models-used-for-testing-and-debugging-1">Trivial models used for testing and debugging</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.TwoSpin.GraphTwoSpin" href="#RRRMC.TwoSpin.GraphTwoSpin"><code>RRRMC.TwoSpin.GraphTwoSpin</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphTwoSpin() &lt;: DiscrGraph</code></pre><p>A trivial <code>DiscrGraph</code> type with 2 spins inteacting ferromagnetically (<span>$J=1$</span>), without fields.</p><p>Only useful for testing/debugging purposes.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.ThreeSpin.GraphThreeSpin" href="#RRRMC.ThreeSpin.GraphThreeSpin"><code>RRRMC.ThreeSpin.GraphThreeSpin</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphThreeSpin() &lt;: DiscrGraph</code></pre><p>A trivial <code>DiscrGraph</code> type with 3 spins, ferromagnetic interactions (<span>$J=1$</span>), no fields, and periodic boundary conditions.</p><p>Only useful for testing/debugging purposes.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.Fields.GraphFields" href="#RRRMC.Fields.GraphFields"><code>RRRMC.Fields.GraphFields</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphFields(N::Integer, LEV::Tuple = (1,)) &lt;: DiscrGraph</code></pre><p>A simple <code>DiscrGraph</code> type with <code>N</code> non-interacting variables, each of which is subject to a local field. The fields are extracted at random from <code>LEV</code>, which must be a <code>Tuple</code> of <code>Real</code>s.</p><p>Mostly useful for testing/debugging purposes.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.Fields.GraphFieldsCont" href="#RRRMC.Fields.GraphFieldsCont"><code>RRRMC.Fields.GraphFieldsCont</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphFieldsCont(N::Integer, LEV::Tuple) &lt;: DoubleGraph</code></pre><p>A simple <code>DoubleGraph</code> type with <code>N</code> non-interacting variables, each of which is subject to a local field. The fields are extracted independently from a normal distribution with unit variance, and then are discretized using the values in <code>LEV</code>, which must be a <code>Tuple</code> of <code>Real</code>s.</p><p>Mostly useful for testing/debugging purposes.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.Ising1D.GraphIsing1D" href="#RRRMC.Ising1D.GraphIsing1D"><code>RRRMC.Ising1D.GraphIsing1D</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphIsing1D(N::Integer) &lt;: DiscrGraph</code></pre><p>A simple 1-dimensional <code>DiscrGraph</code> type with <code>N</code> spins, antiferromagnetic interactions (<span>$J=-1$</span>), no fields, and periodic boundary conditions.</p><p>Mostly useful for testing/debugging purposes.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RRRMC.Q0T.GraphQ0T" href="#RRRMC.Q0T.GraphQ0T"><code>RRRMC.Q0T.GraphQ0T</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GraphQ0T(N::Integer, M::Integer, Γ::Float64, β::Float64) &lt;: DoubleGraph</code></pre><p>A simple <code>DoubleGraph</code> which implements independent spins in a transverse magnetic field, using the Suzuki-Trotter transformation. <code>N</code> is the number of spins, <code>M</code> the number of Suzuki-Trotter replicas, <code>Γ</code> the transverse field, <code>β</code> the inverse temperature.</p><p>Intended for testing/debugging purposes.</p><p>See also <a href="interface.html#RRRMC.QT.Qenergy"><code>Qenergy</code></a>.</p></div></section><footer><hr/><a class="previous" href="graph-types.html"><span class="direction">Previous</span><span class="title">Graph types</span></a><a class="next" href="interface.html"><span class="direction">Next</span><span class="title">Graphs interface</span></a></footer></article></body></html>
